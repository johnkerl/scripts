#!/usr/bin/ruby

@@us = File.basename $0

#require 'enumerator'

# ================================================================
# John Kerl
# 2013-08-19
# http://johnkerl.org
# ----------------------------------------------------------------
# Given CSV input, prints the input but with an extra carriage return when any
# of the values in specified columns changes from one line to the next.
#
# E.g. given input
#
#   a,b,c
#   1,2,3
#   1,2,3
#   1,2,3
#   4,5,6
#   4,5,6
#   4,5,6
#
# cgroup b prints
#
#   a,b,c
#
#   1,2,3
#   1,2,3
#   1,2,3
#
#   4,5,6
#   4,5,6
#   4,5,6
#
# ================================================================

# ----------------------------------------------------------------
def usage()
	puts ""
	puts "Usage: #{@@us} [column delimiters] {comma-separated column names ...} {file names ...}"
	puts "  There must be at least one column name."
	puts "  There may be zero file names, in which case input is taken from stdin."
	puts ""
	puts "Column delimiters for input and output:"
	puts "  -t:  Column delimiter is one tab."
	puts "  -s:  Column delimiter is one or more whitespace characters (default)."
	puts "  -c:  Column delimiter is one comma."
	puts "  -n:  Column delimiter is the empty string, e.g. each character is a column."
	puts ""
	exit 1
end

# ----------------------------------------------------------------
# Defaults:
delimpat = ","
delimout = ","

# Scan the command line for column-delimiter specifications, removing them from
# @ARGV.
while ARGV.length > 0 && ARGV[0] =~ /^-/
	arg = ARGV[0]
	if arg == '--help'
		usage
	elsif arg == '-h'
		usage

	elsif arg == '-t'
		$delimpat = "\t"
		$delimout = "\t"
	elsif arg == '-c'
		$delimpat = ","
		$delimout = ","
	elsif arg == '-s'
		$delimpat = "\s+"
		$delimout = " "
	elsif arg == '-n'
		$delimpat = ""
		$delimout = ""

	else
		print "Unrecognized option \"#{arg}\"."
		usage()
	end
	ARGV.shift
end

# There must be at least one argument for column names.
usage unless ARGV.length > 0

break_column_names = ARGV.shift.split(delimpat)
usage unless break_column_names.length > 0

on_header = true

# Whatever is left on the command line is treated as a file name.
lineno = 0
break_column_indices = []
prev_fields = nil

ARGF.each do |line|
	lineno += 1
	line = line.chomp.rstrip

	curr_fields = line.split(delimpat)

	if on_header
		break_column_names.each do |break_column_name|
			found = false
			curr_fields.each_with_index do |field, i|
				if field == break_column_name
					break_column_indices << i
					found = true
					break
				end
			end
			unless found
				raise "Can't find break column name \"#{break_column_name}\" in header \"#{line}\""
			end
		end

		prev_fields = [nil] * curr_fields.length
		puts line
		on_header = false
	else
		puts if break_column_indices.any?{|i| curr_fields[i] != prev_fields[i]}
		puts line
		prev_fields = curr_fields
	end
end
